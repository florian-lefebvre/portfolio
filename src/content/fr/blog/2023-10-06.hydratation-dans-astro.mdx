---
title: 'Hydratation dans Astro'
description:
    L'hydratation est toujours un point délicat en SSR. Voici un guide rapide
    avec Astro 3 !
thumbnail:
    url: /images/content/en/blog/hydration-in-astro-0.jpg
    alt: Image OpenGraph d'Astro.
category: Développement web
tags:
    [
        Astro,
        Hydratation,
        Programmation,
        Développement web,
        Développement de logiciels,
        SSR,
        Développement fullstack,
        Développement frontend,
    ]
---

Vous êtes-vous déjà trouvé dans une situation où vous deviez hydrater un store
global ou passer des arguments à un script inline ? De nombreux frameworks SSR
s'en charge _plus ou moins_ pour vous, mais pas Astro.

Si vous êtes confronté à ce problème, cet article est fait pour vous !

> Vous avez trouvé un problème, une meilleure solution ou autre chose ?
> [Ouvrez une issue](https://github.com/florian-lefebvre/portfolio) sur mon
> portfolio!

## C'est quoi l'hydratation?

J'emprunte cette très bonne explication à la
[documentation de Vike](https://vike.dev/hydration) :

> Lorsque on fait dur SSR, nos pages sont rendues au format HTML. Mais le HTML
> seul ne suffit pas à rendre une page interactive. Par exemple, une page sans
> JavaScript côté navigateur ne peut pas être interactive (il n'y a pas de
> gestionnaire d'événements JavaScript pour réagir aux actions de l'utilisateur
> telles qu'un clic sur un bouton).
>
> Pour rendre notre page interactive, en plus du rendu de notre page en HTML
> dans Node.js, notre UI framework (Vue/React/...) charge et rend également la
> page dans le navigateur. (Il crée une représentation interne de la page, puis
> fait correspondre la représentation interne aux éléments DOM du code HTML que
> nous avons rendu dans Node.js).
>
> Ce processus est appelé hydratation. De manière informelle, il rend notre page
> interactive/vivante/hydratée.

## Usage dans Astro

Nous allons examiner deux façons d'y parvenir !

### En utilisant `@ayco/astro-resume`

[Ayo Ayco](https://ayo.ayco.io/) a créé ce paquet pour cette situation précise.
Jetez un coup d'œil à la [documentation](https://sr.ht/~ayoayco/astro-resume/)!

Vous pouvez l'utiliser de cette manière :

```astro
---
import Serialize from '@ayco/astro-resume'

const data = {
    hello: 'world',
    isOkay: true,
}
// define the type of data to be serialized
export type Data = typeof data
---

<Serialize id="my-data" {data} />

<script>
    import { deserialize } from '@ayco/astro-resume'
    import type { Data } from './ThisComponent.astro'

    const data = deserialize<Data>('my-data')
    console.log(data) // { hello: 'world', isOkay: true }
</script>
```

Bien que cela fonctionne, je préfère une approche plus manuelle sur laquelle
j'ai un contrôle total.

### En utilisant des scripts et des _data attributes_

Cette approche est en fait inspirée par le fonctionnement d'Astro et de Nuxt !
Regardons d'abord le code :

```astro
---
const someData = { foo: 'bar' }
---

<script is:inline data-state={JSON.stringify(someData)}>
    const state = JSON.parse(
        document.currentScript?.getAttribute('data-state') ?? null
    )

    window.__state = state
</script>

<script>
    // script has no `is:inline`!
    const someData = window.__state
</script>
```

Voici donc comment ça fonctionne :

1. Vous passez vos **données sérialisables** en tant que _data attribute_ à un
   script inline
2. Vous récupérez cette valeur à l'intérieur du script et vous la
   **désérialisez**
3. Vous ajoutez ces données à l'objet global `window`. Comme le script est
   inline, il est exécuté (presque ?) immédiatement
4. Vous pouvez accéder sans problème à vos données dans des scripts `bundled` !

Quelques points importants :

-   Assurez-vous que la propriété que vous définissez sur l'objet `wifnow` n'est
    pas déjà prise. La préfixation par deux underscores semble assez sûre, mais
    vérifiez toujours !
-   Vos données doivent être sérialisables

Si vous utilisez TypeScript (vous devriez vraiment !), il se plaindra que votre
propriété n'existe pas sur l'objet `window`. Vous devez augmenter le type global
:

```ts
// src/env.d.ts

/// <reference types="astro/client" />

interface Window {
    __state: { foo: 'bar' }
}

export {}
```

Il est probable que vous utilisiez un type plus complexe et que vous souhaitiez
donc l'importer. Mais attention ! Vous ne pouvez pas importer un type dans un
fichier `d.ts` comme vous le feriez dans un fichier `ts`. Vous devez utiliser la
syntaxe suivante :

```ts
// src/env.d.ts

/// <reference types="astro/client" />

interface Window {
    __state: import('./my-file').State
}

export {}
```

## Conclusion

Cette approche a probablement des défauts que je ne connais pas (même si
j'espère que ce n'est pas le cas) et j'aimerais le savoir !
[Contactez-moi](#contact) et dites m'en plus !
