---
title: 'op-ent : un ENT open-source'
description:
    Après avoir travaillé sur yNotes, un client non officiel pour les ENT
    existants, il était enfin temps de créer le mien... mais open-source !
thumbnail:
    url: /images/content/en/projects/op-ent-0.jpg
    alt: Lodo d'op-ent
category: Education
tags:
    [
        Education,
        Open Source,
        Web development,
        Platform,
        E-learning,
        React,
        TypeScript,
        AdonisJS,
        Node.js,
        PostgreSQL,
        Redis,
        GraphQL,
        Apollo,
        Figma,
    ]
---

<Alert>

Ce contenu est obsolète. Cependant, il n'est pas complètement hors de propos car
il était vrai dans le passé et aide à comprendre la situation actuelle de ce
projet.

</Alert>

## Introduction

op-ent est un ENT (Espace Numérique de Travail) open-source. Il vise à fournir
des fonctionnalités de base telles que les matières, les notes, le calendrier et
les devoirs dans un 1er temps. L'objectif est de rendre la plateforme plus
unique une fois qu'elle aura atteint la parité avec les concurrents actuels tels
que [EcoleDirecte](https://www.ecoledirecte.com/) et
[Pronote](https://www.ecoledirecte.com/).
[Pronote](https://www.index-education.com/fr/logiciel-gestion-vie-scolaire.php).
Voici quelques idées de fonctionnalités futures :

-   _Gamification_ (système de succès)
-   Un centre de connaissances
-   Signalement anonyme de problèmes, pour le harcèlement scolaire par exmple
-   Un éditeur intégré similaire à [Notion](https://notion/so)

En tant qu'initiateur de ce projet, je travaille sur tous les aspects du
développement, frontend et backend, la conception (y compris le _design system_
et l'identité l'identité de marque), la communication, la gestion de projet et
la gestion de la communauté.

Le projet utilise de nombreuses technologies, notamment :

-   **Frontend**: [TypeScript](https://www.typescriptlang.org/),
    [React](https://reactjs.org/), [Next.js](https://nextjs.org/),
    [Tailwind CSS](https://tailwindcss.com/) et [Axios](https://axios-http.com/)
-   **Backend**: TypeScript, [AdonisJS](https://adonisjs.com/),
    [Node.js](https://nodejs.org/), [PostgreSQL](https://www.postgresql.org/),
    [Redis](https://redis.io/), [GraphQL](https://graphql.org/) (using
    [Apollo](https://www.apollographql.com/)) et WebSockets
-   **Design**: [Figma](https://www.figma.com/)

Il n'y a pas grand-chose à montrer pour l'instant, mais vous pouvez trouver le
projet sur la page de l'[organisation GitHub](https://github.com/op-ent) et sur
le [site web](https://op-ent.fr).

![Capture d'écran de l'organisation GitHub](/images/content/en/projects/op-ent-1.png)

## Objectif

J'ai contribué et maintenu un projet appelé [yNotes](https://ynotes.fr) dans le
passé ([Read more](/fr/projets/ynotes)). L'objectif de yNotes était de fournir
un client non officiel pour les ENTs principaux et était populaire parmi les
étudiants. Bien que le projet ne soit plus maintenu, il a atteint près de 7 000
téléchargements sur Android en décembre 2022, ce qui représente une augmentation
de **250% en deux mois**. Cela montre que que yNotes (et maintenant op-ent)
répondent à un vrai problème : les ENT actuels ne sont pas pas très bons.

Mon objectif est _assez_ simple : Je veux faire d'op-ent l'ENT le plus utilisé
en France. Bien qu'il s'agisse encore d'un projet en cours de réalisation, je
suis persuadé que ce projet a beaucoup de potentiel.

Pour atteindre cet objectif ambitieux, le projet a été divisé en plusieurs
sous-projets, notamment :

-   [unstyled-ui](https://github.com/op-ent/unstyled-ui) : Une bibliothèque de
    composants React _headless_
-   [unstyled-ui-theme](https://github.com/op-ent/unstyled-ui-theme) : Un thème
    pour unstyled-ui
-   [api](https://github.com/op-ent/api) : Le code de l'API
-   [dashboard](https://github.com/op-ent/dashboard) : L'application web

J'ai décidé de ne pas utiliser de monorepo pour ce projet parce que je ne suis
pas très familier avec cela, et je préfère l'approche d'un seul dépôt par projet
utilisée par [AdonisJS] (https://github.com/adonisjs).

## Focus : unstyled-ui

Bien qu'il y ait de nombreux aspects intéressants de l'op-ent à discuter, pour
les besoins de cette page, concentrons-nous sur `unstyled-ui`.

Lien utiles :

-   [Repository GitHub](https://github.com/op-ent/unstyled-ui)
-   [Docs](https://unstyled-ui.docs.op-ent.fr/)

`unstyled-ui` est une bibliothèque de composants React qui a pour but de
résoudre le problème de mélanger des solutions tout-en-un comme
[Material UI](https://material-ui.com) et des solutions headless comme
[Headless UI](https://material-ui.com). Vous pouvez trouver l'intégralité des
motivation de cette bibliothèque
[ici](https://github.com/op-ent/unstyled-ui#motivation). En bref, elle est
configurable, personnalisable et _type-safe_.

En développant cette bibliothèque, j'ai rencontré quelques problèmes :

### Composants polymorphes typés dans React

Selon
[freeCodeCamp](https://www.freecodecamp.org/news/build-strongly-typed-polymorphic-components-with-react-and-typescript)
:

> In the world of React components, a polymorphic component is a component that
> can be rendered with a different container element / node.

Si les composants polymorphes ne sont pas nécessairement difficiles à mettre en
œuvre, obtenir des types soient corrects peut être un défi. Prenons l'exemple
d'un composant appelé `Button` qui devrait être polymorphe parce qu'il peut
parfois être un lien. Dans ce cas, le polymorphisme est contrôlé par la
propriété `as`, qui spécifie le type de l'élément (une chaîne de caractères ou
un composant React). Lorsque l'on appelle le composant comme ceci :

```jsx
<Button as="a" href="/">
    Click!
</Button>
```

Nous voulons que l'IDE fournisse une autocomplétion pour l'élément `a` et non
pour l'élément `button`.

Après avoir fait quelques recherches et expérimentations, j'ai trouvé la
solution suivante (je n'ai pas retrouvé la source exacte) :

```ts
// polymorphic.ts
import type React from 'react'

// Source: https://github.com/emotion-js/emotion/blob/master/packages/styled-base/types/helper.d.ts
// A more precise version of just React.ComponentPropsWithoutRef on its own
export type PropsOf<
    C extends keyof JSX.IntrinsicElements | React.JSXElementConstructor<unknown>
> = JSX.LibraryManagedAttributes<C, React.ComponentPropsWithoutRef<C>>

type AsProp<C extends React.ElementType> = {
    /**
     * An override of the default HTML tag.
     * Can also be another React component.
     */
    as?: C
}

/**
 * Allows for extending a set of props (`ExtendedProps`) by an overriding set of props
 * (`OverrideProps`), ensuring that any duplicates are overridden by the overriding
 * set of props.
 */
export type ExtendableProps<
    ExtendedProps = Record<string, unknown>,
    OverrideProps = Record<string, unknown>
> = OverrideProps & Omit<ExtendedProps, keyof OverrideProps>

/**
 * Allows for inheriting the props from the specified element type so that
 * props like children, className & style work, as well as element-specific
 * attributes like aria roles. The component (`C`) must be passed in.
 */
export type InheritableElementProps<
    C extends React.ElementType,
    Props = Record<string, unknown>
> = ExtendableProps<PropsOf<C>, Props>

/**
 * A more sophisticated version of `InheritableElementProps` where
 * the passed in `as` prop will determine which props can be included
 */
export type PolymorphicComponentProps<
    C extends React.ElementType,
    Props = Record<string, unknown>
> = InheritableElementProps<C, Props & AsProp<C>>

/**
 * Utility type to extract the `ref` prop from a polymorphic component
 */
export type PolymorphicRef<C extends React.ElementType> =
    React.ComponentPropsWithRef<C>['ref']
/**
 * A wrapper of `PolymorphicComponentProps` that also includes the `ref`
 * prop for the polymorphic component
 */

export type PolymorphicComponentPropsWithRef<
    C extends React.ElementType,
    Props = Record<string, unknown>
> = PolymorphicComponentProps<C, Props> & { ref?: PolymorphicRef<C> }

export type ComponentProps<
    C extends React.ElementType,
    P
> = PolymorphicComponentPropsWithRef<C, P>
```

```tsx
// Button.tsx
import React, { forwardRef } from 'react'
import type { ComponentProps, PolymorphicRef } from './polymorphic'

export type ButtonProps = {
    as?: React.ElementType
    children?: React.ReactNode
}

export type ButtonComponent = <C extends React.ElementType = 'button'>(
    props: ComponentProps<C, ButtonProps>
) => React.ReactElement | null

export const Button: ButtonComponent = forwardRef(
    <C extends React.ElementType = 'button'>(
        props: ComponentProps<C, ButtonProps>,
        ref?: PolymorphicRef<C>
    ) => {
        const { as = 'button', children, ...rest } = props
        const Component = as as React.ElementType

        return (
            <Component ref={ref} {...rest}>
                {children}
            </Component>
        )
    }
)
```

### TypeScript et _module override_

Par défaut, `unstyled-ui` ne prend pas trop de décisions sur les props et leurs
typages. Je voulais donc fournir un moyen flexible pour les utilisateurs de la
bibliothèque de de personnaliser et d'étendre les types actuels. Cette idée a
été inspirée par
[Mantine](https://mantine.dev/theming/colors/#add-custom-colors-types) :

```ts
import { Tuple, DefaultMantineColor } from '@mantine/core'

type ExtendedCustomColors =
    | 'primaryColorName'
    | 'secondaryColorName'
    | DefaultMantineColor

declare module '@mantine/core' {
    export interface MantineThemeColorsOverride {
        colors: Record<ExtendedCustomColors, Tuple<string, 10>>
    }
}
```

Cependant, je n'étais pas entièrement satisfait de la manière dont cela
fonctionnait en interne. Je l'ai modifié pour arriver à ce résultat :

```ts
declare module '@op-ent/unstyled-ui' {
    interface CustomizableComponentsPropsOverride {
        button: {
            variant: 'primary' | 'secondary'
        }
    }
}
```

Cela permet aux utilisateurs de créer une configuration correctement typée en
utilisant l'API publique de la bibliothèque :

```ts
export const { config, extendConfig } = createConfig({
    components: {
        button: {
            defaultProps: {
                variant: 'secondary',
            },
            customProps: ['variant'],
        },
    },
})
```

[Voici](https://github.com/op-ent/unstyled-ui/blob/9066cc28e3af96beddd5bfe95378682e5b8268d1/src/types/config.ts)
le code qui rend ça possible :

```ts
import type { DeepPartial } from 'ts-essentials'
import type {
    AccordionProps,
    ButtonProps,
    ButtonGroupProps,
    IconButtonProps,
} from '..'

export type ConfigOverride = DeepPartial<Config>

export type Config = {
    /**
     * Used in {identifierTemplate}
     */
    prefix: string
    /**
     * @default `${prefix}-${id}`
     */
    identifierTemplate: (ctx: { prefix: string; id: string }) => string
    /**
     * @default `data-${prefix}-${prop}`
     */
    dataPropTemplate: (ctx: { prefix: string; prop: string }) => string
    components: ComponentsConfig
}

// eslint-disable-next-line @typescript-eslint/ban-types
export type CustomProps<T extends {}> = (keyof T extends never
    ? string
    : keyof T)[]

export type ComponentName = keyof ComponentsConfig

export type ComponentsConfig = {
    accordion: {
        defaultProps: DeepPartial<AccordionProps>
        customProps: CustomProps<CustomizableComponentsProps['accordion']>
    }
    button: {
        defaultProps: DeepPartial<ButtonProps>
        customProps: CustomProps<CustomizableComponentsProps['button']>
    }
    buttonGroup: {
        defaultProps: DeepPartial<ButtonGroupProps>
        customProps: CustomProps<CustomizableComponentsProps['buttonGroup']>
    }
    iconButton: {
        defaultProps: DeepPartial<IconButtonProps>
        customProps: CustomProps<CustomizableComponentsProps['iconButton']>
    }
}

// eslint-disable-next-line @typescript-eslint/ban-types
export type DefaultCustomizableComponentsProps = Record<ComponentName, {}>

export type CustomizableComponentsPropsOverride = Record<string, never>

export type CustomizableComponentsProps = DefaultCustomizableComponentsProps &
    CustomizableComponentsPropsOverride
```

---

Je suis intéressé par l'exploration des sujets suivants à l'avenir :

-   Stabiliser l'API interne pour faciliter les contributions
-   Rendre `unstyled-ui` _framework agnostic_ pour permettre le partage des
    styles à travers les frameworks d'UI (React, Vue, Svelte...)
-   Permettre la personnalisation du rendu des composants via la configuration
-   Permettre aux utilisateurs d'intégrer facilement des composants
    personnalisés
-   Envisager de renommer `@op-ent/unstyled-ui` en un nom plus court et plus
    mémorable, comme `@uui/core` et `@uui/react`.

![Couverture du repository Unstyled UI](/images/content/en/projects/op-ent-2.png)

## Etat actuel

op-ent est actuellement en cours de développement et ne devrait pas atteindre le
stade alpha ou MVP avant août 2023. Veuillez noter que cette page ne reflète pas
toujours les changements les plus récents, car le projet est susceptible
d'évoluer rapidement.

## Enseignements tirés

Le travail sur l'op-ent a permis de tirer de nombreuses leçons précieuses,
notamment :

-   **La gestion de projet** avec des outils tels que
    [GitHub](https://github.com) et [Linear](https://linear.app)
-   **Le _community management_** sur des plateformes comme GitHub (with issues,
    PRs i.e contributions) et [Discord](https://discord.com)
    ([Rejoignez-nous !](https://discord.gg/kMFmfSbC2C))
-   De nouvelles technologies géniales
-   De l'expérience dans la création et la conception de bibliothèques

Dans l'ensemble, je suis satisfait des technologies que j'ai choisies pour le
projet, à l'exception de certaines bibliothèques de composants comme
[Chakra UI](https://chakra-ui.com/) et [Mantine](https://mantine.dev). Cela m'a
m'a motivé à créer `unstyled-ui`.

Je suis satisfait de l'avancement du projet et je pense qu'il a le potentiel
d'être utile. Si vous souhaitez contribuer au projet ou en savoir plus,
n'hésitez pas à me [contacter](#contact) ou à consulter le
[guide de contribution](https://github.com/op-ent#-contribuer).
