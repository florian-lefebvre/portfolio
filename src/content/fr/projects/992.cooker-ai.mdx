---
title: "Cooker AI : générer des repas à l'aide de l'IA"
description:
    "Trouver des idées pour cuisiner, c'est galère ? Eh bien... ne le faites
    pas."
thumbnail:
    url: /images/content/en/projects/cooker-ai-0.png
    alt:
        "Capture d'écran de la page de planification des repas, contenant
        plusieurs repas générés par l'IA"
category: Développement web
tags:
    [
        Développement web,
        Fullstack,
        Ruby on Rails,
        Ruby,
        Open AI,
        API,
        Tailwind CSS,
        Stimulus,
        Sidekiq,
        Cloudinary,
        Heroku,
        Projet final,
        Le Wagon,
        Bootcamp,
        AI,
        Cuisine,
        Nourriture,
        Suggestions,
    ]
---

## Introduction

Cooker AI est un site web qui vous aide dans cette tâche ennuyeuse : trouver des
idées pour cuisiner. Trouver des idées de repas 14 fois par semaine, c'est
compliqué. Cela représente 728 idées par an ! Solution _facile_ : laisser l'IA
générer des repas pour vous.

Ce site web a quelques fonctionnalités intéressantes :

-   Planifiez vos repas à l'avance grâce à une interface de type calendrier
-   Générez des idées basées sur des paramètres (régime, allergies, durée...)
-   Échangez des repas si nécessaire
-   Régénérez les repas si vous ne les aimez pas
-   Partagez des plans de repas avec d'autres utilisateurs
-   Sauvegardez vos idées préférées

Pour ce projet, j'étais le principal développeur fullstack. Cela signifie que
j'étais en charge du dépôt GitHub, de la gestion de projet, du CI/CD et des
revues de code. I J'ai également beaucoup travaillé sur la maquette du design
UX.

Nous avons utilisé les technologies suivantes :

-   [Ruby on Rails](https://rubyonrails.org/)
-   [Open AI API](https://openai.com/blog/openai-api)
-   [Tailwind CSS](https://tailwindcss.com)
-   [Stimulus](https://stimulus.hotwired.dev/)
-   [Sidekiq](https://sidekiq.org/)
-   [Cloudinary](https://cloudinary.com/)
-   [Heroku](https://www.heroku.com/)

Consultez-le [ici](https://www.cooker-ai.me/)!

![Capture d'écran de la page d'accueil](/images/content/en/projects/cooker-ai-1.png)

## Objectif

[Au Wagon](https://www.lewagon.com/), le bootcamp se termine par un projet de 2
semaines que nous devons présenter le dernier jour (Vous pouvez voir la vidéo
[ici](https://www.youtube.com/watch?v=7d9wfjRtZeM) au fait). J'ai donc présenté
cette idée pendant le bootcamp (j'en avais déjà quelques unes en la matière
depuis un certain temps) et nous avons construit cette application avec
[Maria Skrabalekova](https://github.com/marieSK) et
[Chuma Mukala](https://github.com/ChumaNAM)!

L'objectif du projet était de réinvestir toutes les connaissances acquises au
cours des 2 mois précédents dans une super application (qui fonctionne). Elle
devait inclure des fonctionnalités ambitieuses si possible, c'est pourquoi nous
avons choisi l'IA.

Avant de commencer à coder, nous avons passé du temps à faire des
[recherches UX sur Figma](https://www.figma.com/proto/ai6Y9gflV1fdFakLQ463qq/Cooker-AI-UX-Research?page-id=1%3A4&node-id=11%3A710&viewport=728%2C-175%2C0.42&scaling=scale-down&starting-point-node-id=11%3A710),
à définir nos _user stories_ et le schéma de la base de données.

![Capture d'écran du tableau des _user stories_](/images/content/en/projects/cooker-ai-2.png)

## Focus : génération avec IA

Il y a beaucoup de choses intéressantes dans ce projet (jobs d'arrière-plan,
websockets) mais concentrons-nous sur le point technique principal de ce projet
: la génération avec IA. Nous utilisons 2 modèles d'Open AI :

-   `gpt-3.5-turbo` pour générer les données des repas
-   `dall-e` (résolution 256x256) pour générer des images de repas (oui, même
    celles-ci sont générées par l'IA)

Nous avons cependant été confrontés à quelques problèmes :

### Des résultats incohérents

Pour exploiter les données renvoyées par Chat GPT, nous avions besoin de
résultats au format JSON. Cependant, nous ne pouvons pas l'obliger à renvoyer du
JSON, les résultats pouvaient donc être incohérents.

Pour les améliorer, nous avons travaillé sur 2 axes :

1.  **Un bon _prompt_**: voici à quoi cela ressemble (optimisé par Chat GPT
    lui-même !) :

```
Please provide meal ideas that meet the following criteria:
- All meals must be returned as JSON objects in the following format:
 {
  "date": "yyyy-mm-dd",
  "dish": "name of the meal (e.g. dinner)",
  "name": "name of the dish",
  "ingredients": ["list of ingredients"],
  "steps": ["list of cooking steps"],
  "prep_time": "time needed to prepare the meal"
 }
- I need ideas for #{attrs[:dishes]} for #{attrs[:days]} day#{attrs[:days].to_i == 1 ? "" : "s"}
- The "date" field should be formatted as "yyyy-mm-dd" and the first date should be #{attrs[:date]}.
- Please consider my allergies to #{attrs[:allergies]}.
- I really enjoy #{attrs[:cuisine]} cuisine.
- I follow a #{attrs[:diet]} diet.
- Only return an array of JSON objects (even if there is only one meal idea).
- No sentences, only JSON.
- Any other format will result in a rejected request.
```

2.  **Analyse syntaxique**: Chat GPT ajoute souvent des commentaires avant (et
    même après) le contenu proprement dit, comme par exemple :

```
Here are some meal ideas:

[
    {
        "date": "..."
    }
]
```

Nous avons donc dû analyser un peu tout cela. Ce n'est peut-être pas la façon la
plus propre, mais elle fonctionne :

```ruby
def self.parse_response(res)
    # Remove all the \n junk + ...
    res = res.gsub(/\s+/, " ").strip.gsub("...", "")
    # Chat GPT always says sorry when he can't give only json
    valid = !res.downcase.include?("sorry")
    # In this case we need some manual parsing
    unless valid
        # clean everything that is before the first [
        _trash_content, *remainder = res.split("[")
        res = "[#{remainder.join("[")}"
        # If there is something after the json, clean everything
        # that is after the last ]
        unless res[-1, 1] == "]"
            *remainder, _trash_content = res.split("]")
            res = "#{remainder.join("]")}]"
        end
    end
    return JSON.parse(res)
end
```

### Trouver des recettes à l'aide du web scraping

Comme les résultats peuvent être créatifs avec Chat GPT, il y a eu des cas où
les recettes n'existaient pas sur des sites Internet comme
[allrecipes](https://www.allrecipes.com/). Nous avons même essayé la
[Spoonacular food API](https://spoonacular.com/food-api), mais nous avons
rencontré le même problème. Solution : générer les recettes et toutes les autres
propriétés avec Chat GPT !

En raison du problème ci-dessus, nous ne pouvions pas non plus trouver d'images
sur les sites web. La solution était donc de générer les images avec l'IA. Nous
avons trouvé ça assez drôle !

### C'est lent

C'est un élément sur lequel nous n'avons aucun contrôle. En effet, voici le
nombre de requêtes faites à l'API d'Open AI :

| Modèle   | Nombre d'appels                |
| -------- | ------------------------------ |
| Chat GPT | `1`                            |
| DALL-E   | `numberOfDays * numberOfMeals` |

Comme vous pouvez le constater, tout dépend de l'utilisateur. De plus, cela peut
prendre plus de temps s'il échoue (parce que le JSON n'est pas valide), mais
comme nous générons des tâches en arrière-plan, nous réessayons jusqu'à 3 fois.
Cela minimise le risque d'échec mais augmente le temps d'attente.

## Etat actuel

Aucun autre développement n'est prévu sur ce site. Nous pourrions essayer de
faire un peu de marketing pour voir s'il suscite de l'intérêt. Dans ce cas, nous
ferons des choses mais sinon, le développement est en pause. Mais n'hésitez pas
à l'essayer vous-même !

## Enseignements tirés

Ce projet m'a appris plusieurs choses :

-   Interagir avec l'IA en codant
-   Gestion de projet
-   CI/CD avec Heroku
-   Que je ne suis pas trop nul en programmation : le fait de faire beaucoup de
    revues de code m'a fait réaliser que j'ai une certaine expérience maintenant

Cependant, je ne suis pas un grand fan des technologies utilisées (sauf Tailwind
CSS VS Bootstrap !) : même si Ruby on Rails est puissant, la DX apportée par
TypeScript m'a manquée.
